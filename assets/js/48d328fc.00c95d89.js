"use strict";(self.webpackChunktech_blog=self.webpackChunktech_blog||[]).push([[168],{5388:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>l,frontMatter:()=>i,metadata:()=>a,toc:()=>u});var r=e(5893),c=e(1151);const i={id:"godoc3",title:"Go Concepts",sidebar_label:"Go Concepts"},o=void 0,a={id:"snippets/programming/go/godoc3",title:"Go Concepts",description:"Go Concurrency",source:"@site/docs/snippets/programming/go/godoc3.mdx",sourceDirName:"snippets/programming/go",slug:"/snippets/programming/go/godoc3",permalink:"/docs/snippets/programming/go/godoc3",draft:!1,unlisted:!1,editUrl:"https://github.com/dipjyotimetia/Docs/docs/snippets/programming/go/godoc3.mdx",tags:[],version:"current",frontMatter:{id:"godoc3",title:"Go Concepts",sidebar_label:"Go Concepts"},sidebar:"Docs",previous:{title:"Get Little bit deeper",permalink:"/docs/snippets/programming/go/godoc2"},next:{title:"Get Started",permalink:"/docs/snippets/programming/java/java1"}},s={},u=[{value:"Go Concurrency",id:"go-concurrency",level:2},{value:"Mutex",id:"mutex",level:2},{value:"Generics Queue",id:"generics-queue",level:2},{value:"Generics Stack",id:"generics-stack",level:2},{value:"Generics LinkedList",id:"generics-linkedlist",level:2}];function d(n){const t={code:"code",h2:"h2",pre:"pre",...(0,c.a)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h2,{id:"go-concurrency",children:"Go Concurrency"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'package main\n\nimport (\n\t"context"\n\t"fmt"\n\t"time"\n)\n\nfunc main() {\n\tctx, cancel := context.WithTimeout(context.Background(), 4*time.Second)\n\t_ = cancel // Discard the cancel function, it\'s not used in this example.\n\n\tgo func() {\n\t\t<-ctx.Done()\n\t\tfmt.Println("Context done!")\n\t}()\n\n\tgo func() {\n\t\ttime.Sleep(1 * time.Second)\n\t\tfmt.Println("After 1 second:", ctx.Err())\n\t}()\n\n\tgo func() {\n\t\ttime.Sleep(3 * time.Second)\n\t\tfmt.Println("After 3 seconds:", ctx.Err())\n\t}()\n\n\tgo func() {\n\t\ttime.Sleep(5 * time.Second)\n\t\tfmt.Println("After 5 seconds:", ctx.Err())\n\t}()\n\n\ttime.Sleep(6 * time.Second)\n}\n\nfunc returnAfterNSecond(ctx context.Context, n int, err error) chan error {\n\tch := make(chan error)\n\tgo func() {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tch <- ctx.Err()\n\t\tcase <-time.After(time.Duration(n) * time.Second):\n\t\t\tch <- err\n\t\t}\n\t}()\n\treturn ch\n}\n\n'})}),"\n",(0,r.jsx)(t.h2,{id:"mutex",children:"Mutex"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'package main\n\nimport (\n\t"fmt"\n\t"math/rand"\n\t"sync"\n\t"time"\n)\n\ntype cache struct {\n\tmu sync.Mutex\n\tm  map[string]int\n}\n\nvar inMemoryCache = &cache{m: make(map[string]int)}\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\twg := &sync.WaitGroup{}\n\twg.Add(100)\n\tfor i := 0; i < 100; i++ {\n\t\tgo save(fmt.Sprintf("user_id%d", rand.Intn(100)), rand.Intn(100), wg)\n\t}\n\twg.Wait()\n\tfmt.Println(inMemoryCache.m)\n}\n\nfunc save(k string, v int, wg *sync.WaitGroup) {\n\tinMemoryCache.mu.Lock()\n\tinMemoryCache.m[k] = v\n\tinMemoryCache.mu.Unlock()\n\twg.Done()\n}\n\nfunc saveSlow(k string, v int) {\n\tinMemoryCache.m[k] = v\n}\n\n'})}),"\n",(0,r.jsx)(t.h2,{id:"generics-queue",children:"Generics Queue"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'package main\n\nimport "fmt"\n\ntype Queue[T any] []T\n\nfunc (q *Queue[T]) enqueue(v T) {\n\t*q = append(*q, v)\n}\n\nfunc (q *Queue[T]) dequeue() (T, bool) {\n\tif len(*q) == 0 {\n\t\tvar v T\n\t\treturn v, false\n\t}\n\tv := (*q)[0]\n\t*q = (*q)[1:]\n\treturn v, true\n}\n\n// Queue\nfunc main() {\n\tq := new(Queue[string])\n\tq.enqueue("item-1")\n\tq.enqueue("item-2")\n\tq.enqueue("item-3")\n\tfmt.Println(q)\n\tfmt.Println(q.dequeue())\n\tfmt.Println(q.dequeue())\n\tfmt.Println(q)\n}\n'})}),"\n",(0,r.jsx)(t.h2,{id:"generics-stack",children:"Generics Stack"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'package main\n\nimport "fmt"\n\ntype Stack[T any] []T\n\nfunc (s *Stack[T]) push(v T) {\n\t*s = append([]T{v}, (*s)...)\n}\n\nfunc (s *Stack[T]) pop() (T, bool) {\n\tif len(*s) == 0 {\n\t\tvar v T\n\t\treturn v, false\n\t}\n\tv := (*s)[0]\n\t*s = (*s)[1:]\n\treturn v, true\n}\n\n// Stack\nfunc main() {\n\ts := new(Stack[int])\n\ts.push(1)\n\ts.push(2)\n\ts.push(3)\n\tfmt.Println(s)\n\tfmt.Println(s.pop())\n\tfmt.Println(s.pop())\n\tfmt.Println(s)\n}\n'})}),"\n",(0,r.jsx)(t.h2,{id:"generics-linkedlist",children:"Generics LinkedList"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'package main\n\nimport "fmt"\n\ntype Node[T any] struct {\n\tdata T\n\tnext *Node[T]\n}\n\ntype LinkedList[T any] struct {\n\thead *Node[T]\n}\n\nfunc (l *LinkedList[T]) add(data T) {\n\tnode := &Node[T]{data: data}\n\tif l.head == nil {\n\t\tl.head = node\n\t\treturn\n\t}\n\tcurrent := l.head\n\tfor current.next != nil {\n\t\tcurrent = current.next\n\t}\n\tcurrent.next = node\n}\n\nfunc (l *LinkedList[T]) print() {\n\tcurrent := l.head\n\tfor current != nil {\n\t\tfmt.Println(current.data)\n\t\tcurrent = current.next\n\t}\n}\n\n// LinkedList\nfunc main() {\n\tll := new(LinkedList[float32])\n\tll.add(1.01)\n\tll.add(2.02)\n\tll.add(3.03)\n\tll.print()\n}\n\n'})})]})}function l(n={}){const{wrapper:t}={...(0,c.a)(),...n.components};return t?(0,r.jsx)(t,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},1151:(n,t,e)=>{e.d(t,{Z:()=>a,a:()=>o});var r=e(7294);const c={},i=r.createContext(c);function o(n){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof n?n(t):{...t,...n}}),[t,n])}function a(n){let t;return t=n.disableParentContext?"function"==typeof n.components?n.components(c):n.components||c:o(n.components),r.createElement(i.Provider,{value:t},n.children)}}}]);