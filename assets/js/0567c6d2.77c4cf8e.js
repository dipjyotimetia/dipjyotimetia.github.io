"use strict";(self.webpackChunktech_blog=self.webpackChunktech_blog||[]).push([[3443],{3905:(n,e,t)=>{t.d(e,{Zo:()=>l,kt:()=>g});var r=t(7294);function o(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function c(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function i(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?c(Object(t),!0).forEach((function(e){o(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):c(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function a(n,e){if(null==n)return{};var t,r,o=function(n,e){if(null==n)return{};var t,r,o={},c=Object.keys(n);for(r=0;r<c.length;r++)t=c[r],e.indexOf(t)>=0||(o[t]=n[t]);return o}(n,e);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(n);for(r=0;r<c.length;r++)t=c[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(o[t]=n[t])}return o}var u=r.createContext({}),s=function(n){var e=r.useContext(u),t=e;return n&&(t="function"==typeof n?n(e):i(i({},e),n)),t},l=function(n){var e=s(n.components);return r.createElement(u.Provider,{value:e},n.children)},p="mdxType",m={inlineCode:"code",wrapper:function(n){var e=n.children;return r.createElement(r.Fragment,{},e)}},d=r.forwardRef((function(n,e){var t=n.components,o=n.mdxType,c=n.originalType,u=n.parentName,l=a(n,["components","mdxType","originalType","parentName"]),p=s(t),d=o,g=p["".concat(u,".").concat(d)]||p[d]||m[d]||c;return t?r.createElement(g,i(i({ref:e},l),{},{components:t})):r.createElement(g,i({ref:e},l))}));function g(n,e){var t=arguments,o=e&&e.mdxType;if("string"==typeof n||o){var c=t.length,i=new Array(c);i[0]=d;var a={};for(var u in e)hasOwnProperty.call(e,u)&&(a[u]=e[u]);a.originalType=n,a[p]="string"==typeof n?n:o,i[1]=a;for(var s=2;s<c;s++)i[s]=t[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},9709:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>u,contentTitle:()=>i,default:()=>p,frontMatter:()=>c,metadata:()=>a,toc:()=>s});var r=t(7462),o=(t(7294),t(3905));const c={id:"godoc3",title:"Go Concepts",sidebar_label:"Go Concepts"},i=void 0,a={unversionedId:"snippets/programming/go/godoc3",id:"snippets/programming/go/godoc3",title:"Go Concepts",description:"Go Concurrency",source:"@site/docs/snippets/programming/go/godoc3.md",sourceDirName:"snippets/programming/go",slug:"/snippets/programming/go/godoc3",permalink:"/docs/snippets/programming/go/godoc3",draft:!1,editUrl:"https://github.com/dipjyotimetia/Docs/docs/snippets/programming/go/godoc3.md",tags:[],version:"current",frontMatter:{id:"godoc3",title:"Go Concepts",sidebar_label:"Go Concepts"},sidebar:"Docs",previous:{title:"Get Little bit deeper",permalink:"/docs/snippets/programming/go/godoc2"},next:{title:"Get Started",permalink:"/docs/snippets/programming/java/java1"}},u={},s=[{value:"Go Concurrency",id:"go-concurrency",level:2},{value:"Mutex",id:"mutex",level:2},{value:"Generics Queue",id:"generics-queue",level:2},{value:"Generics Stack",id:"generics-stack",level:2},{value:"Generics LinkedList",id:"generics-linkedlist",level:2}],l={toc:s};function p(n){let{components:e,...t}=n;return(0,o.kt)("wrapper",(0,r.Z)({},l,t,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"go-concurrency"},"Go Concurrency"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "context"\n    "fmt"\n    "time"\n)\n\nfunc main() {\n    ctx, cancel := context.WithTimeout(context.Background(), 4*time.Second)\n    _ = cancel // Discard the cancel function, it\'s not used in this example.\n\n    go func() {\n        <-ctx.Done()\n        fmt.Println("Context done!")\n    }()\n\n    go func() {\n        time.Sleep(1 * time.Second)\n        fmt.Println("After 1 second:", ctx.Err())\n    }()\n\n    go func() {\n        time.Sleep(3 * time.Second)\n        fmt.Println("After 3 seconds:", ctx.Err())\n    }()\n\n    go func() {\n        time.Sleep(5 * time.Second)\n        fmt.Println("After 5 seconds:", ctx.Err())\n    }()\n\n    time.Sleep(6 * time.Second)\n}\n\nfunc returnAfterNSecond(ctx context.Context, n int, err error) chan error {\n    ch := make(chan error)\n    go func() {\n        select {\n        case <-ctx.Done():\n            ch <- ctx.Err()\n        case <-time.After(time.Duration(n) * time.Second):\n            ch <- err\n        }\n    }()\n    return ch\n}\n\n')),(0,o.kt)("h2",{id:"mutex"},"Mutex"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "fmt"\n    "math/rand"\n    "sync"\n    "time"\n)\n\ntype cache struct {\n    mu sync.Mutex\n    m  map[string]int\n}\n\nvar inMemoryCache = &cache{m: make(map[string]int)}\n\nfunc main() {\n    rand.Seed(time.Now().UnixNano())\n    wg := &sync.WaitGroup{}\n    wg.Add(100)\n    for i := 0; i < 100; i++ {\n        go save(fmt.Sprintf("user_id%d", rand.Intn(100)), rand.Intn(100), wg)\n    }\n    wg.Wait()\n    fmt.Println(inMemoryCache.m)\n}\n\nfunc save(k string, v int, wg *sync.WaitGroup) {\n    inMemoryCache.mu.Lock()\n    inMemoryCache.m[k] = v\n    inMemoryCache.mu.Unlock()\n    wg.Done()\n}\n\nfunc saveSlow(k string, v int) {\n    inMemoryCache.m[k] = v\n}\n\n')),(0,o.kt)("h2",{id:"generics-queue"},"Generics Queue"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport "fmt"\n\ntype Queue[T any] []T\n\nfunc (q *Queue[T]) enqueue(v T) {\n    *q = append(*q, v)\n}\n\nfunc (q *Queue[T]) dequeue() (T, bool) {\n    if len(*q) == 0 {\n        var v T\n        return v, false\n    }\n    v := (*q)[0]\n    *q = (*q)[1:]\n    return v, true\n}\n\n// Queue\nfunc main() {\n    q := new(Queue[string])\n    q.enqueue("item-1")\n    q.enqueue("item-2")\n    q.enqueue("item-3")\n    fmt.Println(q)\n    fmt.Println(q.dequeue())\n    fmt.Println(q.dequeue())\n    fmt.Println(q)\n}\n')),(0,o.kt)("h2",{id:"generics-stack"},"Generics Stack"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport "fmt"\n\ntype Stack[T any] []T\n\nfunc (s *Stack[T]) push(v T) {\n    *s = append([]T{v}, (*s)...)\n}\n\nfunc (s *Stack[T]) pop() (T, bool) {\n    if len(*s) == 0 {\n        var v T\n        return v, false\n    }\n    v := (*s)[0]\n    *s = (*s)[1:]\n    return v, true\n}\n\n// Stack\nfunc main() {\n    s := new(Stack[int])\n    s.push(1)\n    s.push(2)\n    s.push(3)\n    fmt.Println(s)\n    fmt.Println(s.pop())\n    fmt.Println(s.pop())\n    fmt.Println(s)\n}\n')),(0,o.kt)("h2",{id:"generics-linkedlist"},"Generics LinkedList"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport "fmt"\n\ntype Node[T any] struct {\n    data T\n    next *Node[T]\n}\n\ntype LinkedList[T any] struct {\n    head *Node[T]\n}\n\nfunc (l *LinkedList[T]) add(data T) {\n    node := &Node[T]{data: data}\n    if l.head == nil {\n        l.head = node\n        return\n    }\n    current := l.head\n    for current.next != nil {\n        current = current.next\n    }\n    current.next = node\n}\n\nfunc (l *LinkedList[T]) print() {\n    current := l.head\n    for current != nil {\n        fmt.Println(current.data)\n        current = current.next\n    }\n}\n\n// LinkedList\nfunc main() {\n    ll := new(LinkedList[float32])\n    ll.add(1.01)\n    ll.add(2.02)\n    ll.add(3.03)\n    ll.print()\n}\n\n')))}p.isMDXComponent=!0}}]);